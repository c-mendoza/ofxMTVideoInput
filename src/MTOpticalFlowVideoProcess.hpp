//
//  MTOpticalFlowVideoProcess.hpp
//  nervousstructureof
//
//  Created by Cristobal Mendoza on 3/14/16.
//
//

#ifndef NSOpticalFlowVideoProcess_hpp
#define NSOpticalFlowVideoProcess_hpp

#include <stdio.h>
#include "ofxCv.h"
#include "MTVideoProcess.hpp"
#include "registry.h"

class MTOpticalFlowVideoProcess : public MTVideoProcess
{

public:

	explicit MTOpticalFlowVideoProcess(std::string name);

	virtual ~MTOpticalFlowVideoProcess()
	{}

	ofParameter<float> learningRate;
	ofParameter<float> fbPolySigma;
	ofParameter<float> lkQualityLevel;
	ofParameter<float> fbPyrScale;
	ofParameter<int> lkMinDistance;
	ofParameter<int> threshold;
	ofParameter<int> lkMaxFeatures;
	ofParameter<int> lkMaxLevel;
	ofParameter<int> fbWinSize;
	ofParameter<int> fbPolyN;
	ofParameter<int> fbIterations;
	ofParameter<int> fbLevels;
	ofParameter<int> lkWinSize;
	ofParameter<bool> fbUseGaussian;
	ofParameter<bool> usefb;
	ofParameter<bool> useBackgroundSub;
	ofParameter<bool> useThreshold;
	ofFastEvent<MTVideoProcessFastEventArgs<MTOpticalFlowVideoProcess>> opticalFlowProcessCompleteFastEvent;


	void notifyEvents() override;

	void drawGui(ofxImGui::Settings& settings) override;
//	virtual void loadFromSerializer(ofXml& serializer);
//	virtual void saveWithSerializer(ofXml& serializer);

	/**
	 * Returns a cv::Mat with the flow vectors. Input image is unchanged
	 */
	cv::Mat process(cv::Mat& image) override;

	ofVec2f getFlowPosition(int x, int y);

private:
	ofxCv::FlowFarneback fb;
	ofxCv::FlowPyrLK lk;
	ofxCv::Flow* curFlow;
	ofxCv::RunningBackground rb;
	cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	cv::Ptr<cv::BackgroundSubtractor> pMOG2;
	cv::Mat workingImage;


};

REGISTER_SUBCLASS(MTVideoProcess, MTOpticalFlowVideoProcess, std::string)

#endif /* NSOpticalFlowVideoProcess_hpp */
